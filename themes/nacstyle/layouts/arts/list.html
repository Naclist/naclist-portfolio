{{ define "main" }}
<main class="content-container">

  <!-- 和其他页面一致的标题层级 -->
  <h1>{{ .Title }}</h1>
  <h2>Research Interest Network</h2>

  <div id="graph-container">
    <div id="graph"></div>

    <div id="legend">
      <h4>Nodes</h4>
      <div><span class="paper-dot"></span> Paper</div>
      <div><span class="keyword-dot"></span> Keyword</div>
    </div>

    <div id="toolbar" style="position:absolute; left:10px; top:10px; z-index:11;">
      <input id="search-box" type="search" placeholder="Search node…"
             style="padding:6px 10px; border:1px solid #bbb; border-radius:6px; width:220px; box-shadow:0 1px 3px rgba(0,0,0,.12);">
    </div>
  </div>

</main>

<style>
  /* 外层容器只做尺寸和内阴影，不再画边框，也禁止 outline，杜绝“双框” */
  #graph-container {
    position: relative;
    width: 100%;
    height: 80vh;
    background-color: #f4f4f4;
    border: none;
    border-radius: 8px;
    margin-top: 12px;
    box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
    overflow: hidden;
    outline: none;
  }
  #graph-container:focus,
  #graph-container:focus-within { outline: none !important; }

  #graph { width: 100%; height: 100%; }

  /* 真正的画布加边框与圆角，只有一层可见边框 */
  #graph > canvas {
    display: block;
    width: 100%;
    height: 100%;
    border: 2px solid #5e7c88;
    border-radius: 8px;
    box-sizing: border-box;
  }

  /* 输入框聚焦时取消系统高亮 */
  #toolbar input:focus { outline: none; box-shadow: 0 0 0 2px rgba(0,0,0,.06); }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.95);
    border: 1px solid #bbb;
    padding: 10px 14px;
    font-size: 13px;
    border-radius: 6px;
    box-shadow: 0 0 6px rgba(0, 0, 0, 0.15);
    z-index: 10;
    line-height: 1.6em;
  }
  #legend h4 { margin: 0 0 5px 0; font-size: 14px; font-weight: bold; }
  #legend div { margin-top: 2px; }
  #legend span {
    display: inline-block; width: 12px; height: 12px; margin-right: 6px;
    vertical-align: middle; border-radius: 50%; border: 1px solid #666;
  }
  .paper-dot { background-color: #EBC03D; }
  .keyword-dot { background-color: #E15D64; }
</style>

<script src="https://unpkg.com/force-graph"></script>
<script>
// ---------- helpers ----------
const getQueryParam = (name) => new URLSearchParams(window.location.search).get(name);
const idOf = v => (v && typeof v === 'object') ? v.id : v;
const slug = s => String(s || '').trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');

function computeDegrees(graph) {
  const deg = Object.create(null);
  (graph.links || []).forEach(l => {
    const s = idOf(l.source), t = idOf(l.target);
    deg[s] = (deg[s] || 0) + 1;
    deg[t] = (deg[t] || 0) + 1;
  });
  (graph.nodes || []).forEach(n => { n.degree = deg[n.id] || 0; });
}

function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

function findKeywordNode(raw, param) {
  if (!param) return null;
  const p = String(param);
  const pslug = slug(p);
  return raw.nodes.find(n => n.type === 'keyword' && (
    n.id === p || n.label === p || slug(n.id) === pslug || slug(n.label) === pslug || n.id === `k-${pslug}`
  )) || null;
}

function subgraphByKeyword(raw, keywordIdOrLabel) {
  const kw = findKeywordNode(raw, keywordIdOrLabel);
  if (!kw) return null;
  const ids = new Set([kw.id]);
  const links = raw.links.filter(l => {
    const s = idOf(l.source), t = idOf(l.target);
    if (s === kw.id || t === kw.id) { ids.add(s); ids.add(t); return true; }
    return false;
  }).map(l => ({ source: idOf(l.source), target: idOf(l.target) }));
  const nodes = raw.nodes.filter(n => ids.has(n.id));
  const sub = { nodes, links };
  computeDegrees(sub);
  return sub;
}

let Graph; // make Graph accessible in helpers

// 适配 GitHub Pages 子路径：不要写死以 / 开头的绝对路径
const graphJsonUrl = '{{ "publications/pub-keyword-graph.json" | relURL }}';

fetch(graphJsonUrl)
  .then(r => r.text())                 // 保持原始文本，避免 FG 在对象上动刀
  .then(text => {
    const raw = JSON.parse(text);
    computeDegrees(raw);

    let showingSub = false;
    let currentKw = null;

    const graphElem = document.getElementById('graph');
    Graph = ForceGraph()(graphElem)
      .nodeId('id')
      .nodeVal(n => n.type === 'keyword' ? 1 + (n.degree || 0) : 2)
      .nodeColor(n => n._match ? (n.type === 'paper' ? '#ffd24d' : '#ff7b88') : (n.type === 'paper' ? '#EBC03D' : '#E15D64'))
      .nodeLabel(n => n.type === 'paper' ? `${n.label}\n(${n.journal}, ${n.year})` : null)
      .nodeCanvasObjectMode(() => 'after')
      .nodeCanvasObject((node, ctx, globalScale) => {
        const radius = Math.sqrt(node.val || 1) * 4;
        if (node._match) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(node.x, node.y, radius + 5, 0, 2*Math.PI);
          ctx.fillStyle = 'rgba(255, 210, 77, 0.25)'; // 高亮光晕
          ctx.fill();
          ctx.restore();
        }
        if (node.type === 'keyword') {
          const fontSize = (6 + (node.degree*0.5 || 0)) / globalScale;
          ctx.font = `${fontSize}px 'Urbanist','El Messiri',sans-serif`;
          ctx.fillStyle = '#444';
          ctx.shadowColor = '#ccc';
          ctx.shadowBlur = 3;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(node.label, node.x, node.y);
          ctx.shadowBlur = 0;
        }
        // 不画描边，避免双框既视感
      })
      .linkColor(l => (l.source && l.source._match) || (l.target && l.target._match) ? '#666' : '#999')
      .linkWidth(l => ((l.source && l.source._match) && (l.target && l.target._match)) ? 4 : 2)
      .onNodeClick(node => {
        if (node.type === 'paper') {
          if (node.url && node.url !== 'NA') window.open(node.url, '_blank');
          return;
        }
        if (node.type === 'keyword') {
          if (showingSub && currentKw === node.id) {
            const full = deepClone(raw); computeDegrees(full); Graph.graphData(full);
            showingSub = false; currentKw = null; clearMatches();
            setTimeout(() => Graph.zoomToFit(400, 40), 200);
          } else {
            const sub = subgraphByKeyword(raw, node.id);
            if (sub) {
              Graph.graphData(sub); clearMatches();
              showingSub = true; currentKw = node.id;
              setTimeout(() => Graph.zoomToFit(400, 40), 200);
            }
          }
        }
      })
      .minZoom(0.8)
      .maxZoom(2.2)
      .enableNodeDrag(true);

    // 初始：全图或 URL 子图 (?keyword= / ?focus=)
    const paramKw = getQueryParam('keyword') || getQueryParam('focus');
    if (paramKw) {
      const sub = subgraphByKeyword(raw, paramKw);
      if (sub) { Graph.graphData(sub); showingSub = true; currentKw = findKeywordNode(raw, paramKw).id; }
      else { const full = deepClone(raw); computeDegrees(full); Graph.graphData(full); }
    } else {
      const full = deepClone(raw); computeDegrees(full); Graph.graphData(full);
    }

    setTimeout(() => Graph.zoomToFit(400, 40), 300);

    // ---------- 搜索高亮 ----------
    const box = document.getElementById('search-box');
    let t = null;
    function clearMatches() {
      const gd = Graph.graphData();
      (gd.nodes || []).forEach(n => n._match = false);
      Graph.nodeColor(Graph.nodeColor());
      Graph.linkColor(Graph.linkColor());
    }
    function applySearch(q) {
      const gd = Graph.graphData();
      const s = String(q || '').trim().toLowerCase();
      (gd.nodes || []).forEach(n => {
        const label = (n.label || n.id || '').toString().toLowerCase();
        n._match = s && label.includes(s);
      });
      Graph.nodeColor(Graph.nodeColor());
      Graph.linkColor(Graph.linkColor());
    }
    box && box.addEventListener('input', e => {
      clearTimeout(t);
      const v = e.target.value;
      if (!v) { t = setTimeout(clearMatches, 120); return; }
      t = setTimeout(() => applySearch(v), 120);
    });
  })
  .catch(err => console.error('Graph load error:', err, 'URL=', graphJsonUrl));
</script>
{{ end }}
